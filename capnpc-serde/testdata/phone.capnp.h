// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: phone.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>
#if !CAPNP_LITE
#include <capnp/capability.h>
#endif  // !CAPNP_LITE

#ifndef CAPNP_VERSION
#error "CAPNP_VERSION is not defined, is capnp/generated-header-support.h missing?"
#elif CAPNP_VERSION != 1000002
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(d826df210eab943e);
CAPNP_DECLARE_SCHEMA(b1160a9612be6406);
CAPNP_DECLARE_SCHEMA(d175887b9d397b4a);
CAPNP_DECLARE_SCHEMA(ed5bcc458b243f52);
CAPNP_DECLARE_SCHEMA(d68b5724fed51061);
CAPNP_DECLARE_SCHEMA(e1432335ec44693f);
enum class Type_e1432335ec44693f: uint16_t {
  MOBILE,
  HOME,
  WORK,
};
CAPNP_DECLARE_ENUM(Type, e1432335ec44693f);
CAPNP_DECLARE_SCHEMA(c32ffe503b3bd079);
CAPNP_DECLARE_SCHEMA(ed22c6bdcbf439b3);
CAPNP_DECLARE_SCHEMA(ef29c66fa74a8c93);
CAPNP_DECLARE_SCHEMA(d4fcf3a4a6432d22);

}  // namespace schemas
}  // namespace capnp


struct PHoneIF {
  PHoneIF() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct TestMessageParams;
  struct TestMessageResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(d826df210eab943e)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct PHoneIF::TestMessageParams {
  TestMessageParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b1160a9612be6406, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PHoneIF::TestMessageResults {
  TestMessageResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d175887b9d397b4a, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Person {
  Person() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct PhoneNumber;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ed5bcc458b243f52, 0, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Person::PhoneNumber {
  PhoneNumber() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  typedef ::capnp::schemas::Type_e1432335ec44693f Type;


  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d68b5724fed51061, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Dymmy {
  Dymmy() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c32ffe503b3bd079, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct DymmyB {
  DymmyB() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ed22c6bdcbf439b3, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

template <typename YEARTYPE = ::capnp::AnyPointer>
struct Date {
  Date() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct DymmyA;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ef29c66fa74a8c93, 1, 2)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, YEARTYPE>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename YEARTYPE>
struct Date<YEARTYPE>::DymmyA {
  DymmyA() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d4fcf3a4a6432d22, 0, 2)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, YEARTYPE>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

#if !CAPNP_LITE
class PHoneIF::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef PHoneIF Calls;
  typedef PHoneIF Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::PHoneIF::TestMessageParams,  ::PHoneIF::TestMessageResults> testMessageRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class PHoneIF::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef PHoneIF Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::PHoneIF::TestMessageParams TestMessageParams;
  typedef  ::PHoneIF::TestMessageResults TestMessageResults;
  typedef ::capnp::CallContext<TestMessageParams, TestMessageResults> TestMessageContext;
  virtual ::kj::Promise<void> testMessage(TestMessageContext context);

  inline  ::PHoneIF::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::PHoneIF>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class PHoneIF::TestMessageParams::Reader {
public:
  typedef TestMessageParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasA() const;
  inline  ::Person::Reader getA() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PHoneIF::TestMessageParams::Builder {
public:
  typedef TestMessageParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasA();
  inline  ::Person::Builder getA();
  inline void setA( ::Person::Reader value);
  inline  ::Person::Builder initA();
  inline void adoptA(::capnp::Orphan< ::Person>&& value);
  inline ::capnp::Orphan< ::Person> disownA();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PHoneIF::TestMessageParams::Pipeline {
public:
  typedef TestMessageParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Person::Pipeline getA();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PHoneIF::TestMessageResults::Reader {
public:
  typedef TestMessageResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int8_t getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PHoneIF::TestMessageResults::Builder {
public:
  typedef TestMessageResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int8_t getResult();
  inline void setResult( ::int8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PHoneIF::TestMessageResults::Pipeline {
public:
  typedef TestMessageResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Person::Reader {
public:
  typedef Person Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool hasEmail() const;
  inline  ::capnp::Text::Reader getEmail() const;

  inline bool hasPhones() const;
  inline  ::capnp::List< ::Person::PhoneNumber,  ::capnp::Kind::STRUCT>::Reader getPhones() const;

  inline bool hasBirthdate() const;
  inline  ::Date< ::DymmyB>::Reader getBirthdate() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Person::Builder {
public:
  typedef Person Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool hasEmail();
  inline  ::capnp::Text::Builder getEmail();
  inline void setEmail( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initEmail(unsigned int size);
  inline void adoptEmail(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownEmail();

  inline bool hasPhones();
  inline  ::capnp::List< ::Person::PhoneNumber,  ::capnp::Kind::STRUCT>::Builder getPhones();
  inline void setPhones( ::capnp::List< ::Person::PhoneNumber,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::Person::PhoneNumber,  ::capnp::Kind::STRUCT>::Builder initPhones(unsigned int size);
  inline void adoptPhones(::capnp::Orphan< ::capnp::List< ::Person::PhoneNumber,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::Person::PhoneNumber,  ::capnp::Kind::STRUCT>> disownPhones();

  inline bool hasBirthdate();
  inline  ::Date< ::DymmyB>::Builder getBirthdate();
  inline void setBirthdate( ::Date< ::DymmyB>::Reader value);
  inline  ::Date< ::DymmyB>::Builder initBirthdate();
  inline void adoptBirthdate(::capnp::Orphan< ::Date< ::DymmyB>>&& value);
  inline ::capnp::Orphan< ::Date< ::DymmyB>> disownBirthdate();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Person::Pipeline {
public:
  typedef Person Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Date< ::DymmyB>::Pipeline getBirthdate();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Person::PhoneNumber::Reader {
public:
  typedef PhoneNumber Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasNumber() const;
  inline  ::capnp::Text::Reader getNumber() const;

  inline  ::Person::PhoneNumber::Type getType() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Person::PhoneNumber::Builder {
public:
  typedef PhoneNumber Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasNumber();
  inline  ::capnp::Text::Builder getNumber();
  inline void setNumber( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initNumber(unsigned int size);
  inline void adoptNumber(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownNumber();

  inline  ::Person::PhoneNumber::Type getType();
  inline void setType( ::Person::PhoneNumber::Type value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Person::PhoneNumber::Pipeline {
public:
  typedef PhoneNumber Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Dymmy::Reader {
public:
  typedef Dymmy Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getYear() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Dymmy::Builder {
public:
  typedef Dymmy Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getYear();
  inline void setYear( ::uint16_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Dymmy::Pipeline {
public:
  typedef Dymmy Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class DymmyB::Reader {
public:
  typedef DymmyB Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int8_t getAa() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class DymmyB::Builder {
public:
  typedef DymmyB Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int8_t getAa();
  inline void setAa( ::int8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class DymmyB::Pipeline {
public:
  typedef DymmyB Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename YEARTYPE>
class Date<YEARTYPE>::Reader {
public:
  typedef Date Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename YEARTYPE2 = ::capnp::AnyPointer>
  typename Date<YEARTYPE2>::Reader asGeneric() {
    return typename Date<YEARTYPE2>::Reader(_reader);
  }

  inline bool hasYear() const;
  inline  ::capnp::ReaderFor<YEARTYPE> getYear() const;

  inline  ::uint8_t getMonth() const;

  inline  ::uint8_t getDay() const;

  inline bool hasTest() const;
  inline typename  ::Date<YEARTYPE>::DymmyA::Reader getTest() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename YEARTYPE>
class Date<YEARTYPE>::Builder {
public:
  typedef Date Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename YEARTYPE2 = ::capnp::AnyPointer>
  typename Date<YEARTYPE2>::Builder asGeneric() {
    return typename Date<YEARTYPE2>::Builder(_builder);
  }

  inline bool hasYear();
  inline  ::capnp::BuilderFor<YEARTYPE> getYear();
  inline void setYear( ::capnp::ReaderFor<YEARTYPE> value);
  inline  ::capnp::BuilderFor<YEARTYPE> initYear();
  inline  ::capnp::BuilderFor<YEARTYPE> initYear(unsigned int size);
  inline void adoptYear(::capnp::Orphan<YEARTYPE>&& value);
  inline ::capnp::Orphan<YEARTYPE> disownYear();

  inline  ::uint8_t getMonth();
  inline void setMonth( ::uint8_t value);

  inline  ::uint8_t getDay();
  inline void setDay( ::uint8_t value);

  inline bool hasTest();
  inline typename  ::Date<YEARTYPE>::DymmyA::Builder getTest();
  inline void setTest(typename  ::Date<YEARTYPE>::DymmyA::Reader value);
  inline typename  ::Date<YEARTYPE>::DymmyA::Builder initTest();
  inline void adoptTest(::capnp::Orphan<typename  ::Date<YEARTYPE>::DymmyA>&& value);
  inline ::capnp::Orphan<typename  ::Date<YEARTYPE>::DymmyA> disownTest();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename YEARTYPE>
class Date<YEARTYPE>::Pipeline {
public:
  typedef Date Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<YEARTYPE> getYear();
  inline typename  ::Date<YEARTYPE>::DymmyA::Pipeline getTest();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename YEARTYPE>
class Date<YEARTYPE>::DymmyA::Reader {
public:
  typedef DymmyA Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename YEARTYPE2 = ::capnp::AnyPointer>
  typename Date<YEARTYPE2>::DymmyA::Reader asDateGeneric() {
    return typename Date<YEARTYPE2>::DymmyA::Reader(_reader);
  }

  inline bool hasYear() const;
  inline  ::Date< ::Dymmy>::Reader getYear() const;

  inline bool hasTest() const;
  inline  ::capnp::ReaderFor<YEARTYPE> getTest() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename YEARTYPE>
class Date<YEARTYPE>::DymmyA::Builder {
public:
  typedef DymmyA Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename YEARTYPE2 = ::capnp::AnyPointer>
  typename Date<YEARTYPE2>::DymmyA::Builder asDateGeneric() {
    return typename Date<YEARTYPE2>::DymmyA::Builder(_builder);
  }

  inline bool hasYear();
  inline  ::Date< ::Dymmy>::Builder getYear();
  inline void setYear( ::Date< ::Dymmy>::Reader value);
  inline  ::Date< ::Dymmy>::Builder initYear();
  inline void adoptYear(::capnp::Orphan< ::Date< ::Dymmy>>&& value);
  inline ::capnp::Orphan< ::Date< ::Dymmy>> disownYear();

  inline bool hasTest();
  inline  ::capnp::BuilderFor<YEARTYPE> getTest();
  inline void setTest( ::capnp::ReaderFor<YEARTYPE> value);
  inline  ::capnp::BuilderFor<YEARTYPE> initTest();
  inline  ::capnp::BuilderFor<YEARTYPE> initTest(unsigned int size);
  inline void adoptTest(::capnp::Orphan<YEARTYPE>&& value);
  inline ::capnp::Orphan<YEARTYPE> disownTest();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename YEARTYPE>
class Date<YEARTYPE>::DymmyA::Pipeline {
public:
  typedef DymmyA Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Date< ::Dymmy>::Pipeline getYear();
  inline  ::capnp::PipelineFor<YEARTYPE> getTest();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

#if !CAPNP_LITE
inline PHoneIF::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline PHoneIF::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline PHoneIF::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline PHoneIF::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline PHoneIF::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::PHoneIF::Client& PHoneIF::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::PHoneIF::Client& PHoneIF::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool PHoneIF::TestMessageParams::Reader::hasA() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool PHoneIF::TestMessageParams::Builder::hasA() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::Person::Reader PHoneIF::TestMessageParams::Reader::getA() const {
  return ::capnp::_::PointerHelpers< ::Person>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::Person::Builder PHoneIF::TestMessageParams::Builder::getA() {
  return ::capnp::_::PointerHelpers< ::Person>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Person::Pipeline PHoneIF::TestMessageParams::Pipeline::getA() {
  return  ::Person::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void PHoneIF::TestMessageParams::Builder::setA( ::Person::Reader value) {
  ::capnp::_::PointerHelpers< ::Person>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::Person::Builder PHoneIF::TestMessageParams::Builder::initA() {
  return ::capnp::_::PointerHelpers< ::Person>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void PHoneIF::TestMessageParams::Builder::adoptA(
    ::capnp::Orphan< ::Person>&& value) {
  ::capnp::_::PointerHelpers< ::Person>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Person> PHoneIF::TestMessageParams::Builder::disownA() {
  return ::capnp::_::PointerHelpers< ::Person>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::int8_t PHoneIF::TestMessageResults::Reader::getResult() const {
  return _reader.getDataField< ::int8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int8_t PHoneIF::TestMessageResults::Builder::getResult() {
  return _builder.getDataField< ::int8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void PHoneIF::TestMessageResults::Builder::setResult( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Person::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Person::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Person::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Person::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Person::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Person::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Person::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Person::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Person::Reader::hasEmail() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Person::Builder::hasEmail() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Person::Reader::getEmail() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Person::Builder::getEmail() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Person::Builder::setEmail( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Person::Builder::initEmail(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Person::Builder::adoptEmail(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Person::Builder::disownEmail() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Person::Reader::hasPhones() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Person::Builder::hasPhones() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::Person::PhoneNumber,  ::capnp::Kind::STRUCT>::Reader Person::Reader::getPhones() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Person::PhoneNumber,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::Person::PhoneNumber,  ::capnp::Kind::STRUCT>::Builder Person::Builder::getPhones() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Person::PhoneNumber,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Person::Builder::setPhones( ::capnp::List< ::Person::PhoneNumber,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Person::PhoneNumber,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::Person::PhoneNumber,  ::capnp::Kind::STRUCT>::Builder Person::Builder::initPhones(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Person::PhoneNumber,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void Person::Builder::adoptPhones(
    ::capnp::Orphan< ::capnp::List< ::Person::PhoneNumber,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::Person::PhoneNumber,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::Person::PhoneNumber,  ::capnp::Kind::STRUCT>> Person::Builder::disownPhones() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::Person::PhoneNumber,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Person::Reader::hasBirthdate() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Person::Builder::hasBirthdate() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::Date< ::DymmyB>::Reader Person::Reader::getBirthdate() const {
  return ::capnp::_::PointerHelpers< ::Date< ::DymmyB>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::Date< ::DymmyB>::Builder Person::Builder::getBirthdate() {
  return ::capnp::_::PointerHelpers< ::Date< ::DymmyB>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Date< ::DymmyB>::Pipeline Person::Pipeline::getBirthdate() {
  return  ::Date< ::DymmyB>::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void Person::Builder::setBirthdate( ::Date< ::DymmyB>::Reader value) {
  ::capnp::_::PointerHelpers< ::Date< ::DymmyB>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::Date< ::DymmyB>::Builder Person::Builder::initBirthdate() {
  return ::capnp::_::PointerHelpers< ::Date< ::DymmyB>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Person::Builder::adoptBirthdate(
    ::capnp::Orphan< ::Date< ::DymmyB>>&& value) {
  ::capnp::_::PointerHelpers< ::Date< ::DymmyB>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Date< ::DymmyB>> Person::Builder::disownBirthdate() {
  return ::capnp::_::PointerHelpers< ::Date< ::DymmyB>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Person::PhoneNumber::Reader::hasNumber() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Person::PhoneNumber::Builder::hasNumber() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Person::PhoneNumber::Reader::getNumber() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Person::PhoneNumber::Builder::getNumber() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Person::PhoneNumber::Builder::setNumber( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Person::PhoneNumber::Builder::initNumber(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Person::PhoneNumber::Builder::adoptNumber(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Person::PhoneNumber::Builder::disownNumber() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::Person::PhoneNumber::Type Person::PhoneNumber::Reader::getType() const {
  return _reader.getDataField< ::Person::PhoneNumber::Type>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::Person::PhoneNumber::Type Person::PhoneNumber::Builder::getType() {
  return _builder.getDataField< ::Person::PhoneNumber::Type>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Person::PhoneNumber::Builder::setType( ::Person::PhoneNumber::Type value) {
  _builder.setDataField< ::Person::PhoneNumber::Type>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint16_t Dymmy::Reader::getYear() const {
  return _reader.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint16_t Dymmy::Builder::getYear() {
  return _builder.getDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Dymmy::Builder::setYear( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int8_t DymmyB::Reader::getAa() const {
  return _reader.getDataField< ::int8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int8_t DymmyB::Builder::getAa() {
  return _builder.getDataField< ::int8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void DymmyB::Builder::setAa( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

template <typename YEARTYPE>
inline bool Date<YEARTYPE>::Reader::hasYear() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename YEARTYPE>
inline bool Date<YEARTYPE>::Builder::hasYear() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename YEARTYPE>
inline  ::capnp::ReaderFor<YEARTYPE> Date<YEARTYPE>::Reader::getYear() const {
  return ::capnp::_::PointerHelpers<YEARTYPE>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename YEARTYPE>
inline  ::capnp::BuilderFor<YEARTYPE> Date<YEARTYPE>::Builder::getYear() {
  return ::capnp::_::PointerHelpers<YEARTYPE>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename YEARTYPE>
inline  ::capnp::PipelineFor<YEARTYPE> Date<YEARTYPE>::Pipeline::getYear() {
  return  ::capnp::PipelineFor<YEARTYPE>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename YEARTYPE>
inline void Date<YEARTYPE>::Builder::setYear( ::capnp::ReaderFor<YEARTYPE> value) {
  ::capnp::_::PointerHelpers<YEARTYPE>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename YEARTYPE>
inline  ::capnp::BuilderFor<YEARTYPE> Date<YEARTYPE>::Builder::initYear() {
  return ::capnp::_::PointerHelpers<YEARTYPE>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename YEARTYPE>
inline  ::capnp::BuilderFor<YEARTYPE> Date<YEARTYPE>::Builder::initYear(unsigned int size) {
  return ::capnp::_::PointerHelpers<YEARTYPE>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename YEARTYPE>
inline void Date<YEARTYPE>::Builder::adoptYear(
    ::capnp::Orphan<YEARTYPE>&& value) {
  ::capnp::_::PointerHelpers<YEARTYPE>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename YEARTYPE>
inline ::capnp::Orphan<YEARTYPE> Date<YEARTYPE>::Builder::disownYear() {
  return ::capnp::_::PointerHelpers<YEARTYPE>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename YEARTYPE>
inline  ::uint8_t Date<YEARTYPE>::Reader::getMonth() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

template <typename YEARTYPE>
inline  ::uint8_t Date<YEARTYPE>::Builder::getMonth() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
template <typename YEARTYPE>
inline void Date<YEARTYPE>::Builder::setMonth( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

template <typename YEARTYPE>
inline  ::uint8_t Date<YEARTYPE>::Reader::getDay() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

template <typename YEARTYPE>
inline  ::uint8_t Date<YEARTYPE>::Builder::getDay() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
template <typename YEARTYPE>
inline void Date<YEARTYPE>::Builder::setDay( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

template <typename YEARTYPE>
inline bool Date<YEARTYPE>::Reader::hasTest() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename YEARTYPE>
inline bool Date<YEARTYPE>::Builder::hasTest() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename YEARTYPE>
inline typename  ::Date<YEARTYPE>::DymmyA::Reader Date<YEARTYPE>::Reader::getTest() const {
  return ::capnp::_::PointerHelpers<typename  ::Date<YEARTYPE>::DymmyA>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename YEARTYPE>
inline typename  ::Date<YEARTYPE>::DymmyA::Builder Date<YEARTYPE>::Builder::getTest() {
  return ::capnp::_::PointerHelpers<typename  ::Date<YEARTYPE>::DymmyA>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename YEARTYPE>
inline typename  ::Date<YEARTYPE>::DymmyA::Pipeline Date<YEARTYPE>::Pipeline::getTest() {
  return typename  ::Date<YEARTYPE>::DymmyA::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
template <typename YEARTYPE>
inline void Date<YEARTYPE>::Builder::setTest(typename  ::Date<YEARTYPE>::DymmyA::Reader value) {
  ::capnp::_::PointerHelpers<typename  ::Date<YEARTYPE>::DymmyA>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename YEARTYPE>
inline typename  ::Date<YEARTYPE>::DymmyA::Builder Date<YEARTYPE>::Builder::initTest() {
  return ::capnp::_::PointerHelpers<typename  ::Date<YEARTYPE>::DymmyA>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename YEARTYPE>
inline void Date<YEARTYPE>::Builder::adoptTest(
    ::capnp::Orphan<typename  ::Date<YEARTYPE>::DymmyA>&& value) {
  ::capnp::_::PointerHelpers<typename  ::Date<YEARTYPE>::DymmyA>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename YEARTYPE>
inline ::capnp::Orphan<typename  ::Date<YEARTYPE>::DymmyA> Date<YEARTYPE>::Builder::disownTest() {
  return ::capnp::_::PointerHelpers<typename  ::Date<YEARTYPE>::DymmyA>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

template <typename YEARTYPE>
inline bool Date<YEARTYPE>::DymmyA::Reader::hasYear() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename YEARTYPE>
inline bool Date<YEARTYPE>::DymmyA::Builder::hasYear() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename YEARTYPE>
inline  ::Date< ::Dymmy>::Reader Date<YEARTYPE>::DymmyA::Reader::getYear() const {
  return ::capnp::_::PointerHelpers< ::Date< ::Dymmy>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename YEARTYPE>
inline  ::Date< ::Dymmy>::Builder Date<YEARTYPE>::DymmyA::Builder::getYear() {
  return ::capnp::_::PointerHelpers< ::Date< ::Dymmy>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename YEARTYPE>
inline  ::Date< ::Dymmy>::Pipeline Date<YEARTYPE>::DymmyA::Pipeline::getYear() {
  return  ::Date< ::Dymmy>::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename YEARTYPE>
inline void Date<YEARTYPE>::DymmyA::Builder::setYear( ::Date< ::Dymmy>::Reader value) {
  ::capnp::_::PointerHelpers< ::Date< ::Dymmy>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename YEARTYPE>
inline  ::Date< ::Dymmy>::Builder Date<YEARTYPE>::DymmyA::Builder::initYear() {
  return ::capnp::_::PointerHelpers< ::Date< ::Dymmy>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename YEARTYPE>
inline void Date<YEARTYPE>::DymmyA::Builder::adoptYear(
    ::capnp::Orphan< ::Date< ::Dymmy>>&& value) {
  ::capnp::_::PointerHelpers< ::Date< ::Dymmy>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename YEARTYPE>
inline ::capnp::Orphan< ::Date< ::Dymmy>> Date<YEARTYPE>::DymmyA::Builder::disownYear() {
  return ::capnp::_::PointerHelpers< ::Date< ::Dymmy>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename YEARTYPE>
inline bool Date<YEARTYPE>::DymmyA::Reader::hasTest() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename YEARTYPE>
inline bool Date<YEARTYPE>::DymmyA::Builder::hasTest() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename YEARTYPE>
inline  ::capnp::ReaderFor<YEARTYPE> Date<YEARTYPE>::DymmyA::Reader::getTest() const {
  return ::capnp::_::PointerHelpers<YEARTYPE>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename YEARTYPE>
inline  ::capnp::BuilderFor<YEARTYPE> Date<YEARTYPE>::DymmyA::Builder::getTest() {
  return ::capnp::_::PointerHelpers<YEARTYPE>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename YEARTYPE>
inline  ::capnp::PipelineFor<YEARTYPE> Date<YEARTYPE>::DymmyA::Pipeline::getTest() {
  return  ::capnp::PipelineFor<YEARTYPE>(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
template <typename YEARTYPE>
inline void Date<YEARTYPE>::DymmyA::Builder::setTest( ::capnp::ReaderFor<YEARTYPE> value) {
  ::capnp::_::PointerHelpers<YEARTYPE>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename YEARTYPE>
inline  ::capnp::BuilderFor<YEARTYPE> Date<YEARTYPE>::DymmyA::Builder::initTest() {
  return ::capnp::_::PointerHelpers<YEARTYPE>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename YEARTYPE>
inline  ::capnp::BuilderFor<YEARTYPE> Date<YEARTYPE>::DymmyA::Builder::initTest(unsigned int size) {
  return ::capnp::_::PointerHelpers<YEARTYPE>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
template <typename YEARTYPE>
inline void Date<YEARTYPE>::DymmyA::Builder::adoptTest(
    ::capnp::Orphan<YEARTYPE>&& value) {
  ::capnp::_::PointerHelpers<YEARTYPE>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename YEARTYPE>
inline ::capnp::Orphan<YEARTYPE> Date<YEARTYPE>::DymmyA::Builder::disownTest() {
  return ::capnp::_::PointerHelpers<YEARTYPE>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

// Date<YEARTYPE>::DymmyA
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename YEARTYPE>
constexpr uint16_t Date<YEARTYPE>::DymmyA::_capnpPrivate::dataWordSize;
template <typename YEARTYPE>
constexpr uint16_t Date<YEARTYPE>::DymmyA::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename YEARTYPE>
constexpr ::capnp::Kind Date<YEARTYPE>::DymmyA::_capnpPrivate::kind;
template <typename YEARTYPE>
constexpr ::capnp::_::RawSchema const* Date<YEARTYPE>::DymmyA::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename YEARTYPE>
const ::capnp::_::RawBrandedSchema::Scope Date<YEARTYPE>::DymmyA::_capnpPrivate::brandScopes[] = {
  { 0xef29c66fa74a8c93, brandBindings + 0, 1, false},
};
template <typename YEARTYPE>
const ::capnp::_::RawBrandedSchema::Binding Date<YEARTYPE>::DymmyA::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<YEARTYPE>(),
};
template <typename YEARTYPE>
const ::capnp::_::RawBrandedSchema::Dependency Date<YEARTYPE>::DymmyA::_capnpPrivate::brandDependencies[] = {
  { 16777216,  ::Date< ::Dymmy>::_capnpPrivate::brand() },
};
template <typename YEARTYPE>
const ::capnp::_::RawBrandedSchema Date<YEARTYPE>::DymmyA::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_d4fcf3a4a6432d22, brandScopes, brandDependencies,
  1, 1, nullptr
};
#endif  // !CAPNP_LITE

// Date<YEARTYPE>
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename YEARTYPE>
constexpr uint16_t Date<YEARTYPE>::_capnpPrivate::dataWordSize;
template <typename YEARTYPE>
constexpr uint16_t Date<YEARTYPE>::_capnpPrivate::pointerCount;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
#if !CAPNP_LITE
#if CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename YEARTYPE>
constexpr ::capnp::Kind Date<YEARTYPE>::_capnpPrivate::kind;
template <typename YEARTYPE>
constexpr ::capnp::_::RawSchema const* Date<YEARTYPE>::_capnpPrivate::schema;
#endif  // !CAPNP_NEED_REDUNDANT_CONSTEXPR_DECL
template <typename YEARTYPE>
const ::capnp::_::RawBrandedSchema::Scope Date<YEARTYPE>::_capnpPrivate::brandScopes[] = {
  { 0xef29c66fa74a8c93, brandBindings + 0, 1, false},
};
template <typename YEARTYPE>
const ::capnp::_::RawBrandedSchema::Binding Date<YEARTYPE>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<YEARTYPE>(),
};
template <typename YEARTYPE>
const ::capnp::_::RawBrandedSchema::Dependency Date<YEARTYPE>::_capnpPrivate::brandDependencies[] = {
  { 16777219,  ::Date<YEARTYPE>::DymmyA::_capnpPrivate::brand() },
};
template <typename YEARTYPE>
const ::capnp::_::RawBrandedSchema Date<YEARTYPE>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_ef29c66fa74a8c93, brandScopes, brandDependencies,
  1, 1, nullptr
};
#endif  // !CAPNP_LITE


CAPNP_END_HEADER

